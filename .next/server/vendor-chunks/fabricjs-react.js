"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fabricjs-react";
exports.ids = ["vendor-chunks/fabricjs-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/fabricjs-react/dist/fabricjs-react.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/fabricjs-react/dist/fabricjs-react.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FabricJSCanvas: () => (/* binding */ Tr),\n/* harmony export */   useFabricJSEditor: () => (/* binding */ _r)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fabric */ \"(ssr)/./node_modules/fabric/dist/fabric.js\");\n\n\nconst Y = \"#000000\", re = \"rgba(255, 255, 255, 0.0)\", br = {\n  radius: 20,\n  left: 100,\n  top: 100,\n  fill: re,\n  stroke: Y\n}, Er = {\n  left: 100,\n  top: 100,\n  fill: re,\n  stroke: Y,\n  width: 40,\n  height: 40,\n  angle: 0\n}, we = {\n  points: [50, 100, 200, 200],\n  options: {\n    left: 170,\n    top: 150,\n    stroke: Y\n  }\n}, ee = {\n  type: \"text\",\n  left: 100,\n  top: 100,\n  fontSize: 16,\n  fontFamily: \"Arial\",\n  fill: Y\n}, gr = (i, h, m, y, p, _) => ({\n  canvas: i,\n  addCircle: () => {\n    const a = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Circle({\n      ...br,\n      fill: h,\n      stroke: m\n    });\n    i.add(a);\n  },\n  addRectangle: () => {\n    const a = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Rect({\n      ...Er,\n      fill: h,\n      stroke: m\n    });\n    i.add(a);\n  },\n  addLine: () => {\n    const a = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Line(we.points, {\n      ...we.options,\n      stroke: m\n    });\n    i.add(a);\n  },\n  addText: (a) => {\n    const c = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Textbox(a, {\n      ...ee,\n      fill: m\n    });\n    c.set({\n      text: a\n    }), i.add(c);\n  },\n  updateText: (a) => {\n    const c = i.getActiveObjects();\n    c.length && c[0].type === ee.type && (c[0].set({\n      text: a\n    }), i.renderAll());\n  },\n  deleteAll: () => {\n    i.getObjects().forEach((a) => i.remove(a)), i.discardActiveObject(), i.renderAll();\n  },\n  deleteSelected: () => {\n    i.getActiveObjects().forEach((a) => i.remove(a)), i.discardActiveObject(), i.renderAll();\n  },\n  fillColor: h,\n  strokeColor: m,\n  setFillColor: (a) => {\n    y(a), i.getActiveObjects().forEach((c) => c.set({\n      fill: a\n    })), i.renderAll();\n  },\n  setStrokeColor: (a) => {\n    p(a), i.getActiveObjects().forEach((c) => {\n      if (c.type === ee.type) {\n        c.set({\n          fill: a\n        });\n        return;\n      }\n      c.set({\n        stroke: a\n      });\n    }), i.renderAll();\n  },\n  zoomIn: () => {\n    const a = i.getZoom();\n    i.setZoom(a / _);\n  },\n  zoomOut: () => {\n    const a = i.getZoom();\n    i.setZoom(a * _);\n  }\n}), _r = (i = {}) => {\n  const h = i.scaleStep || 0.5, {\n    defaultFillColor: m,\n    defaultStrokeColor: y\n  } = i, [p, _] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [a, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(m || re), [f, w] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(y || Y), [b, R] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    p && ((j) => {\n      j.on(\"selection:cleared\", () => {\n        R([]);\n      }), j.on(\"selection:created\", (x) => {\n        R(x.selected);\n      }), j.on(\"selection:updated\", (x) => {\n        R(x.selected);\n      });\n    })(p);\n  }, [p]), {\n    selectedObjects: b,\n    onReady: (O) => {\n      console.log(\"Fabric canvas ready\"), _(O);\n    },\n    editor: p ? gr(p, a, f, c, w, h) : void 0\n  };\n};\nvar Fe = { exports: {} }, L = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar je;\nfunction hr() {\n  if (je)\n    return L;\n  je = 1;\n  var i = react__WEBPACK_IMPORTED_MODULE_0__, h = Symbol.for(\"react.element\"), m = Symbol.for(\"react.fragment\"), y = Object.prototype.hasOwnProperty, p = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, _ = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function a(c, f, w) {\n    var b, R = {}, O = null, j = null;\n    w !== void 0 && (O = \"\" + w), f.key !== void 0 && (O = \"\" + f.key), f.ref !== void 0 && (j = f.ref);\n    for (b in f)\n      y.call(f, b) && !_.hasOwnProperty(b) && (R[b] = f[b]);\n    if (c && c.defaultProps)\n      for (b in f = c.defaultProps, f)\n        R[b] === void 0 && (R[b] = f[b]);\n    return { $$typeof: h, type: c, key: O, ref: j, props: R, _owner: p.current };\n  }\n  return L.Fragment = m, L.jsx = a, L.jsxs = a, L;\n}\nvar W = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Pe;\nfunction mr() {\n  return Pe || (Pe = 1,  true && function() {\n    var i = react__WEBPACK_IMPORTED_MODULE_0__, h = Symbol.for(\"react.element\"), m = Symbol.for(\"react.portal\"), y = Symbol.for(\"react.fragment\"), p = Symbol.for(\"react.strict_mode\"), _ = Symbol.for(\"react.profiler\"), a = Symbol.for(\"react.provider\"), c = Symbol.for(\"react.context\"), f = Symbol.for(\"react.forward_ref\"), w = Symbol.for(\"react.suspense\"), b = Symbol.for(\"react.suspense_list\"), R = Symbol.for(\"react.memo\"), O = Symbol.for(\"react.lazy\"), j = Symbol.for(\"react.offscreen\"), x = Symbol.iterator, De = \"@@iterator\";\n    function Ie(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = x && e[x] || e[De];\n      return typeof r == \"function\" ? r : null;\n    }\n    var k = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function E(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        Le(\"error\", e, t);\n      }\n    }\n    function Le(e, r, t) {\n      {\n        var n = k.ReactDebugCurrentFrame, u = n.getStackAddendum();\n        u !== \"\" && (r += \"%s\", t = t.concat([u]));\n        var l = t.map(function(s) {\n          return String(s);\n        });\n        l.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, l);\n      }\n    }\n    var We = !1, $e = !1, Ye = !1, Ne = !1, Ve = !1, te;\n    te = Symbol.for(\"react.module.reference\");\n    function Me(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === y || e === _ || Ve || e === p || e === w || e === b || Ne || e === j || We || $e || Ye || typeof e == \"object\" && e !== null && (e.$$typeof === O || e.$$typeof === R || e.$$typeof === a || e.$$typeof === c || e.$$typeof === f || e.$$typeof === te || e.getModuleId !== void 0));\n    }\n    function Ue(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var u = r.displayName || r.name || \"\";\n      return u !== \"\" ? t + \"(\" + u + \")\" : t;\n    }\n    function ne(e) {\n      return e.displayName || \"Context\";\n    }\n    function C(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && E(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case y:\n          return \"Fragment\";\n        case m:\n          return \"Portal\";\n        case _:\n          return \"Profiler\";\n        case p:\n          return \"StrictMode\";\n        case w:\n          return \"Suspense\";\n        case b:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case c:\n            var r = e;\n            return ne(r) + \".Consumer\";\n          case a:\n            var t = e;\n            return ne(t._context) + \".Provider\";\n          case f:\n            return Ue(e, e.render, \"ForwardRef\");\n          case R:\n            var n = e.displayName || null;\n            return n !== null ? n : C(e.type) || \"Memo\";\n          case O: {\n            var u = e, l = u._payload, s = u._init;\n            try {\n              return C(s(l));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var P = Object.assign, D = 0, ae, oe, ie, se, ue, le, ce;\n    function fe() {\n    }\n    fe.__reactDisabledLog = !0;\n    function ze() {\n      {\n        if (D === 0) {\n          ae = console.log, oe = console.info, ie = console.warn, se = console.error, ue = console.group, le = console.groupCollapsed, ce = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: fe,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        D++;\n      }\n    }\n    function Be() {\n      {\n        if (D--, D === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: P({}, e, {\n              value: ae\n            }),\n            info: P({}, e, {\n              value: oe\n            }),\n            warn: P({}, e, {\n              value: ie\n            }),\n            error: P({}, e, {\n              value: se\n            }),\n            group: P({}, e, {\n              value: ue\n            }),\n            groupCollapsed: P({}, e, {\n              value: le\n            }),\n            groupEnd: P({}, e, {\n              value: ce\n            })\n          });\n        }\n        D < 0 && E(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var J = k.ReactCurrentDispatcher, q;\n    function N(e, r, t) {\n      {\n        if (q === void 0)\n          try {\n            throw Error();\n          } catch (u) {\n            var n = u.stack.trim().match(/\\n( *(at )?)/);\n            q = n && n[1] || \"\";\n          }\n        return `\n` + q + e;\n      }\n    }\n    var G = !1, V;\n    {\n      var Je = typeof WeakMap == \"function\" ? WeakMap : Map;\n      V = new Je();\n    }\n    function de(e, r) {\n      if (!e || G)\n        return \"\";\n      {\n        var t = V.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      G = !0;\n      var u = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var l;\n      l = J.current, J.current = null, ze();\n      try {\n        if (r) {\n          var s = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(s.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(s, []);\n            } catch (S) {\n              n = S;\n            }\n            Reflect.construct(e, [], s);\n          } else {\n            try {\n              s.call();\n            } catch (S) {\n              n = S;\n            }\n            e.call(s.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (S) {\n            n = S;\n          }\n          e();\n        }\n      } catch (S) {\n        if (S && n && typeof S.stack == \"string\") {\n          for (var o = S.stack.split(`\n`), g = n.stack.split(`\n`), d = o.length - 1, v = g.length - 1; d >= 1 && v >= 0 && o[d] !== g[v]; )\n            v--;\n          for (; d >= 1 && v >= 0; d--, v--)\n            if (o[d] !== g[v]) {\n              if (d !== 1 || v !== 1)\n                do\n                  if (d--, v--, v < 0 || o[d] !== g[v]) {\n                    var T = `\n` + o[d].replace(\" at new \", \" at \");\n                    return e.displayName && T.includes(\"<anonymous>\") && (T = T.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && V.set(e, T), T;\n                  }\n                while (d >= 1 && v >= 0);\n              break;\n            }\n        }\n      } finally {\n        G = !1, J.current = l, Be(), Error.prepareStackTrace = u;\n      }\n      var F = e ? e.displayName || e.name : \"\", Ce = F ? N(F) : \"\";\n      return typeof e == \"function\" && V.set(e, Ce), Ce;\n    }\n    function qe(e, r, t) {\n      return de(e, !1);\n    }\n    function Ge(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function M(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return de(e, Ge(e));\n      if (typeof e == \"string\")\n        return N(e);\n      switch (e) {\n        case w:\n          return N(\"Suspense\");\n        case b:\n          return N(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case f:\n            return qe(e.render);\n          case R:\n            return M(e.type, r, t);\n          case O: {\n            var n = e, u = n._payload, l = n._init;\n            try {\n              return M(l(u), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var U = Object.prototype.hasOwnProperty, ve = {}, pe = k.ReactDebugCurrentFrame;\n    function z(e) {\n      if (e) {\n        var r = e._owner, t = M(e.type, e._source, r ? r.type : null);\n        pe.setExtraStackFrame(t);\n      } else\n        pe.setExtraStackFrame(null);\n    }\n    function He(e, r, t, n, u) {\n      {\n        var l = Function.call.bind(U);\n        for (var s in e)\n          if (l(e, s)) {\n            var o = void 0;\n            try {\n              if (typeof e[s] != \"function\") {\n                var g = Error((n || \"React class\") + \": \" + t + \" type `\" + s + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[s] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw g.name = \"Invariant Violation\", g;\n              }\n              o = e[s](r, s, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (d) {\n              o = d;\n            }\n            o && !(o instanceof Error) && (z(u), E(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, s, typeof o), z(null)), o instanceof Error && !(o.message in ve) && (ve[o.message] = !0, z(u), E(\"Failed %s type: %s\", t, o.message), z(null));\n          }\n      }\n    }\n    var Ke = Array.isArray;\n    function H(e) {\n      return Ke(e);\n    }\n    function Ze(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Xe(e) {\n      try {\n        return be(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function be(e) {\n      return \"\" + e;\n    }\n    function Ee(e) {\n      if (Xe(e))\n        return E(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Ze(e)), be(e);\n    }\n    var I = k.ReactCurrentOwner, Qe = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, ge, he, K;\n    K = {};\n    function er(e) {\n      if (U.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function rr(e) {\n      if (U.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function tr(e, r) {\n      if (typeof e.ref == \"string\" && I.current && r && I.current.stateNode !== r) {\n        var t = C(I.current.type);\n        K[t] || (E('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', C(I.current.type), e.ref), K[t] = !0);\n      }\n    }\n    function nr(e, r) {\n      {\n        var t = function() {\n          ge || (ge = !0, E(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function ar(e, r) {\n      {\n        var t = function() {\n          he || (he = !0, E(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var or = function(e, r, t, n, u, l, s) {\n      var o = {\n        $$typeof: h,\n        type: e,\n        key: r,\n        ref: t,\n        props: s,\n        _owner: l\n      };\n      return o._store = {}, Object.defineProperty(o._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(o, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(o, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: u\n      }), Object.freeze && (Object.freeze(o.props), Object.freeze(o)), o;\n    };\n    function ir(e, r, t, n, u) {\n      {\n        var l, s = {}, o = null, g = null;\n        t !== void 0 && (Ee(t), o = \"\" + t), rr(r) && (Ee(r.key), o = \"\" + r.key), er(r) && (g = r.ref, tr(r, u));\n        for (l in r)\n          U.call(r, l) && !Qe.hasOwnProperty(l) && (s[l] = r[l]);\n        if (e && e.defaultProps) {\n          var d = e.defaultProps;\n          for (l in d)\n            s[l] === void 0 && (s[l] = d[l]);\n        }\n        if (o || g) {\n          var v = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          o && nr(s, v), g && ar(s, v);\n        }\n        return or(e, o, g, u, n, I.current, s);\n      }\n    }\n    var Z = k.ReactCurrentOwner, me = k.ReactDebugCurrentFrame;\n    function A(e) {\n      if (e) {\n        var r = e._owner, t = M(e.type, e._source, r ? r.type : null);\n        me.setExtraStackFrame(t);\n      } else\n        me.setExtraStackFrame(null);\n    }\n    var X;\n    X = !1;\n    function Q(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === h;\n    }\n    function ye() {\n      {\n        if (Z.current) {\n          var e = C(Z.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function sr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Re = {};\n    function ur(e) {\n      {\n        var r = ye();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function _e(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = ur(r);\n        if (Re[t])\n          return;\n        Re[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== Z.current && (n = \" It was passed a child from \" + C(e._owner.type) + \".\"), A(e), E('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), A(null);\n      }\n    }\n    function Te(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (H(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            Q(n) && _e(n, r);\n          }\n        else if (Q(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var u = Ie(e);\n          if (typeof u == \"function\" && u !== e.entries)\n            for (var l = u.call(e), s; !(s = l.next()).done; )\n              Q(s.value) && _e(s.value, r);\n        }\n      }\n    }\n    function lr(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === f || r.$$typeof === R))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = C(r);\n          He(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !X) {\n          X = !0;\n          var u = C(r);\n          E(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", u || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && E(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function cr(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            A(e), E(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), A(null);\n            break;\n          }\n        }\n        e.ref !== null && (A(e), E(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), A(null));\n      }\n    }\n    function Oe(e, r, t, n, u, l) {\n      {\n        var s = Me(e);\n        if (!s) {\n          var o = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (o += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var g = sr(u);\n          g ? o += g : o += ye();\n          var d;\n          e === null ? d = \"null\" : H(e) ? d = \"array\" : e !== void 0 && e.$$typeof === h ? (d = \"<\" + (C(e.type) || \"Unknown\") + \" />\", o = \" Did you accidentally export a JSX literal instead of a component?\") : d = typeof e, E(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", d, o);\n        }\n        var v = ir(e, r, t, u, l);\n        if (v == null)\n          return v;\n        if (s) {\n          var T = r.children;\n          if (T !== void 0)\n            if (n)\n              if (H(T)) {\n                for (var F = 0; F < T.length; F++)\n                  Te(T[F], e);\n                Object.freeze && Object.freeze(T);\n              } else\n                E(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Te(T, e);\n        }\n        return e === y ? cr(v) : lr(v), v;\n      }\n    }\n    function fr(e, r, t) {\n      return Oe(e, r, t, !0);\n    }\n    function dr(e, r, t) {\n      return Oe(e, r, t, !1);\n    }\n    var vr = dr, pr = fr;\n    W.Fragment = y, W.jsx = vr, W.jsxs = pr;\n  }()), W;\n}\n(function(i) {\n   false ? 0 : i.exports = mr();\n})(Fe);\nconst xe = Fe.exports.jsx, Tr = ({\n  className: i,\n  onReady: h\n}) => {\n  const m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const p = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Canvas(m.current), _ = () => {\n      var c, f;\n      p.setHeight(((c = y.current) == null ? void 0 : c.clientHeight) || 0), p.setWidth(((f = y.current) == null ? void 0 : f.clientWidth) || 0), p.renderAll();\n    }, a = () => {\n      _();\n    };\n    return _(), window.addEventListener(\"resize\", a, !1), h && h(p), () => {\n      p.dispose(), window.removeEventListener(\"resize\", a);\n    };\n  }, []), /* @__PURE__ */ xe(\"div\", {\n    ref: y,\n    className: i,\n    children: /* @__PURE__ */ xe(\"canvas\", {\n      ref: m\n    })\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFicmljanMtcmVhY3QvZGlzdC9mYWJyaWNqcy1yZWFjdC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlFO0FBQ3BDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrQkFBa0IsMENBQUM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBDQUFDO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiwwQ0FBQztBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBDQUFDO0FBQ25CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLElBQUksY0FBYywrQ0FBQyxpQkFBaUIsK0NBQUMsb0JBQW9CLCtDQUFDLG1CQUFtQiwrQ0FBQztBQUM5RSxTQUFTLGdEQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBRSw0TEFBNEw7QUFDeE07QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RCxZQUFZLGtDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsTUFBcUMsR0FBRyxDQUFnQjtBQUMxRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVksNkNBQUUsWUFBWSw2Q0FBRTtBQUM1QixTQUFTLGdEQUFFO0FBQ1gsa0JBQWtCLDBDQUFDO0FBQ25CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0X2FkbWluX25leHRfYXBwLy4vbm9kZV9tb2R1bGVzL2ZhYnJpY2pzLXJlYWN0L2Rpc3QvZmFicmljanMtcmVhY3QuZXMuanM/NzMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQga2UsIHsgdXNlU3RhdGUgYXMgQiwgdXNlRWZmZWN0IGFzIEFlLCB1c2VSZWYgYXMgU2UgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZhYnJpYyBhcyAkIH0gZnJvbSBcImZhYnJpY1wiO1xuY29uc3QgWSA9IFwiIzAwMDAwMFwiLCByZSA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjApXCIsIGJyID0ge1xuICByYWRpdXM6IDIwLFxuICBsZWZ0OiAxMDAsXG4gIHRvcDogMTAwLFxuICBmaWxsOiByZSxcbiAgc3Ryb2tlOiBZXG59LCBFciA9IHtcbiAgbGVmdDogMTAwLFxuICB0b3A6IDEwMCxcbiAgZmlsbDogcmUsXG4gIHN0cm9rZTogWSxcbiAgd2lkdGg6IDQwLFxuICBoZWlnaHQ6IDQwLFxuICBhbmdsZTogMFxufSwgd2UgPSB7XG4gIHBvaW50czogWzUwLCAxMDAsIDIwMCwgMjAwXSxcbiAgb3B0aW9uczoge1xuICAgIGxlZnQ6IDE3MCxcbiAgICB0b3A6IDE1MCxcbiAgICBzdHJva2U6IFlcbiAgfVxufSwgZWUgPSB7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBsZWZ0OiAxMDAsXG4gIHRvcDogMTAwLFxuICBmb250U2l6ZTogMTYsXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZmlsbDogWVxufSwgZ3IgPSAoaSwgaCwgbSwgeSwgcCwgXykgPT4gKHtcbiAgY2FudmFzOiBpLFxuICBhZGRDaXJjbGU6ICgpID0+IHtcbiAgICBjb25zdCBhID0gbmV3ICQuQ2lyY2xlKHtcbiAgICAgIC4uLmJyLFxuICAgICAgZmlsbDogaCxcbiAgICAgIHN0cm9rZTogbVxuICAgIH0pO1xuICAgIGkuYWRkKGEpO1xuICB9LFxuICBhZGRSZWN0YW5nbGU6ICgpID0+IHtcbiAgICBjb25zdCBhID0gbmV3ICQuUmVjdCh7XG4gICAgICAuLi5FcixcbiAgICAgIGZpbGw6IGgsXG4gICAgICBzdHJva2U6IG1cbiAgICB9KTtcbiAgICBpLmFkZChhKTtcbiAgfSxcbiAgYWRkTGluZTogKCkgPT4ge1xuICAgIGNvbnN0IGEgPSBuZXcgJC5MaW5lKHdlLnBvaW50cywge1xuICAgICAgLi4ud2Uub3B0aW9ucyxcbiAgICAgIHN0cm9rZTogbVxuICAgIH0pO1xuICAgIGkuYWRkKGEpO1xuICB9LFxuICBhZGRUZXh0OiAoYSkgPT4ge1xuICAgIGNvbnN0IGMgPSBuZXcgJC5UZXh0Ym94KGEsIHtcbiAgICAgIC4uLmVlLFxuICAgICAgZmlsbDogbVxuICAgIH0pO1xuICAgIGMuc2V0KHtcbiAgICAgIHRleHQ6IGFcbiAgICB9KSwgaS5hZGQoYyk7XG4gIH0sXG4gIHVwZGF0ZVRleHQ6IChhKSA9PiB7XG4gICAgY29uc3QgYyA9IGkuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgIGMubGVuZ3RoICYmIGNbMF0udHlwZSA9PT0gZWUudHlwZSAmJiAoY1swXS5zZXQoe1xuICAgICAgdGV4dDogYVxuICAgIH0pLCBpLnJlbmRlckFsbCgpKTtcbiAgfSxcbiAgZGVsZXRlQWxsOiAoKSA9PiB7XG4gICAgaS5nZXRPYmplY3RzKCkuZm9yRWFjaCgoYSkgPT4gaS5yZW1vdmUoYSkpLCBpLmRpc2NhcmRBY3RpdmVPYmplY3QoKSwgaS5yZW5kZXJBbGwoKTtcbiAgfSxcbiAgZGVsZXRlU2VsZWN0ZWQ6ICgpID0+IHtcbiAgICBpLmdldEFjdGl2ZU9iamVjdHMoKS5mb3JFYWNoKChhKSA9PiBpLnJlbW92ZShhKSksIGkuZGlzY2FyZEFjdGl2ZU9iamVjdCgpLCBpLnJlbmRlckFsbCgpO1xuICB9LFxuICBmaWxsQ29sb3I6IGgsXG4gIHN0cm9rZUNvbG9yOiBtLFxuICBzZXRGaWxsQ29sb3I6IChhKSA9PiB7XG4gICAgeShhKSwgaS5nZXRBY3RpdmVPYmplY3RzKCkuZm9yRWFjaCgoYykgPT4gYy5zZXQoe1xuICAgICAgZmlsbDogYVxuICAgIH0pKSwgaS5yZW5kZXJBbGwoKTtcbiAgfSxcbiAgc2V0U3Ryb2tlQ29sb3I6IChhKSA9PiB7XG4gICAgcChhKSwgaS5nZXRBY3RpdmVPYmplY3RzKCkuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgaWYgKGMudHlwZSA9PT0gZWUudHlwZSkge1xuICAgICAgICBjLnNldCh7XG4gICAgICAgICAgZmlsbDogYVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYy5zZXQoe1xuICAgICAgICBzdHJva2U6IGFcbiAgICAgIH0pO1xuICAgIH0pLCBpLnJlbmRlckFsbCgpO1xuICB9LFxuICB6b29tSW46ICgpID0+IHtcbiAgICBjb25zdCBhID0gaS5nZXRab29tKCk7XG4gICAgaS5zZXRab29tKGEgLyBfKTtcbiAgfSxcbiAgem9vbU91dDogKCkgPT4ge1xuICAgIGNvbnN0IGEgPSBpLmdldFpvb20oKTtcbiAgICBpLnNldFpvb20oYSAqIF8pO1xuICB9XG59KSwgX3IgPSAoaSA9IHt9KSA9PiB7XG4gIGNvbnN0IGggPSBpLnNjYWxlU3RlcCB8fCAwLjUsIHtcbiAgICBkZWZhdWx0RmlsbENvbG9yOiBtLFxuICAgIGRlZmF1bHRTdHJva2VDb2xvcjogeVxuICB9ID0gaSwgW3AsIF9dID0gQihudWxsKSwgW2EsIGNdID0gQihtIHx8IHJlKSwgW2YsIHddID0gQih5IHx8IFkpLCBbYiwgUl0gPSBCKFtdKTtcbiAgcmV0dXJuIEFlKCgpID0+IHtcbiAgICBwICYmICgoaikgPT4ge1xuICAgICAgai5vbihcInNlbGVjdGlvbjpjbGVhcmVkXCIsICgpID0+IHtcbiAgICAgICAgUihbXSk7XG4gICAgICB9KSwgai5vbihcInNlbGVjdGlvbjpjcmVhdGVkXCIsICh4KSA9PiB7XG4gICAgICAgIFIoeC5zZWxlY3RlZCk7XG4gICAgICB9KSwgai5vbihcInNlbGVjdGlvbjp1cGRhdGVkXCIsICh4KSA9PiB7XG4gICAgICAgIFIoeC5zZWxlY3RlZCk7XG4gICAgICB9KTtcbiAgICB9KShwKTtcbiAgfSwgW3BdKSwge1xuICAgIHNlbGVjdGVkT2JqZWN0czogYixcbiAgICBvblJlYWR5OiAoTykgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCJGYWJyaWMgY2FudmFzIHJlYWR5XCIpLCBfKE8pO1xuICAgIH0sXG4gICAgZWRpdG9yOiBwID8gZ3IocCwgYSwgZiwgYywgdywgaCkgOiB2b2lkIDBcbiAgfTtcbn07XG52YXIgRmUgPSB7IGV4cG9ydHM6IHt9IH0sIEwgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBqZTtcbmZ1bmN0aW9uIGhyKCkge1xuICBpZiAoamUpXG4gICAgcmV0dXJuIEw7XG4gIGplID0gMTtcbiAgdmFyIGkgPSBrZSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBtID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCB5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgcCA9IGkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIF8gPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiBhKGMsIGYsIHcpIHtcbiAgICB2YXIgYiwgUiA9IHt9LCBPID0gbnVsbCwgaiA9IG51bGw7XG4gICAgdyAhPT0gdm9pZCAwICYmIChPID0gXCJcIiArIHcpLCBmLmtleSAhPT0gdm9pZCAwICYmIChPID0gXCJcIiArIGYua2V5KSwgZi5yZWYgIT09IHZvaWQgMCAmJiAoaiA9IGYucmVmKTtcbiAgICBmb3IgKGIgaW4gZilcbiAgICAgIHkuY2FsbChmLCBiKSAmJiAhXy5oYXNPd25Qcm9wZXJ0eShiKSAmJiAoUltiXSA9IGZbYl0pO1xuICAgIGlmIChjICYmIGMuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChiIGluIGYgPSBjLmRlZmF1bHRQcm9wcywgZilcbiAgICAgICAgUltiXSA9PT0gdm9pZCAwICYmIChSW2JdID0gZltiXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IGgsIHR5cGU6IGMsIGtleTogTywgcmVmOiBqLCBwcm9wczogUiwgX293bmVyOiBwLmN1cnJlbnQgfTtcbiAgfVxuICByZXR1cm4gTC5GcmFnbWVudCA9IG0sIEwuanN4ID0gYSwgTC5qc3hzID0gYSwgTDtcbn1cbnZhciBXID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgUGU7XG5mdW5jdGlvbiBtcigpIHtcbiAgcmV0dXJuIFBlIHx8IChQZSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IGtlLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCB5ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBwID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBfID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIHcgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGIgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgUiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBPID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGogPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCB4ID0gU3ltYm9sLml0ZXJhdG9yLCBEZSA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIEllKGUpIHtcbiAgICAgIGlmIChlID09PSBudWxsIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHIgPSB4ICYmIGVbeF0gfHwgZVtEZV07XG4gICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gciA6IG51bGw7XG4gICAgfVxuICAgIHZhciBrID0gaS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBFKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkociA+IDEgPyByIC0gMSA6IDApLCBuID0gMTsgbiA8IHI7IG4rKylcbiAgICAgICAgICB0W24gLSAxXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgICAgTGUoXCJlcnJvclwiLCBlLCB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gTGUoZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICB2YXIgbiA9IGsuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgdSA9IG4uZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICB1ICE9PSBcIlwiICYmIChyICs9IFwiJXNcIiwgdCA9IHQuY29uY2F0KFt1XSkpO1xuICAgICAgICB2YXIgbCA9IHQubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbC51bnNoaWZ0KFwiV2FybmluZzogXCIgKyByKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtlXSwgY29uc29sZSwgbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBXZSA9ICExLCAkZSA9ICExLCBZZSA9ICExLCBOZSA9ICExLCBWZSA9ICExLCB0ZTtcbiAgICB0ZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIE1lKGUpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBlID09PSB5IHx8IGUgPT09IF8gfHwgVmUgfHwgZSA9PT0gcCB8fCBlID09PSB3IHx8IGUgPT09IGIgfHwgTmUgfHwgZSA9PT0gaiB8fCBXZSB8fCAkZSB8fCBZZSB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgKGUuJCR0eXBlb2YgPT09IE8gfHwgZS4kJHR5cGVvZiA9PT0gUiB8fCBlLiQkdHlwZW9mID09PSBhIHx8IGUuJCR0eXBlb2YgPT09IGMgfHwgZS4kJHR5cGVvZiA9PT0gZiB8fCBlLiQkdHlwZW9mID09PSB0ZSB8fCBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVWUoZSwgciwgdCkge1xuICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lO1xuICAgICAgaWYgKG4pXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgdmFyIHUgPSByLmRpc3BsYXlOYW1lIHx8IHIubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIHUgIT09IFwiXCIgPyB0ICsgXCIoXCIgKyB1ICsgXCIpXCIgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZShlKSB7XG4gICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhlKSB7XG4gICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZS50YWcgPT0gXCJudW1iZXJcIiAmJiBFKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSB5OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgbTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBfOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgcDpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgdzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgdmFyIHIgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIG5lKHIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICB2YXIgdCA9IGU7XG4gICAgICAgICAgICByZXR1cm4gbmUodC5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgIHJldHVybiBVZShlLCBlLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgIHZhciBuID0gZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG4gIT09IG51bGwgPyBuIDogQyhlLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgTzoge1xuICAgICAgICAgICAgdmFyIHUgPSBlLCBsID0gdS5fcGF5bG9hZCwgcyA9IHUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gQyhzKGwpKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgUCA9IE9iamVjdC5hc3NpZ24sIEQgPSAwLCBhZSwgb2UsIGllLCBzZSwgdWUsIGxlLCBjZTtcbiAgICBmdW5jdGlvbiBmZSgpIHtcbiAgICB9XG4gICAgZmUuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gemUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChEID09PSAwKSB7XG4gICAgICAgICAgYWUgPSBjb25zb2xlLmxvZywgb2UgPSBjb25zb2xlLmluZm8sIGllID0gY29uc29sZS53YXJuLCBzZSA9IGNvbnNvbGUuZXJyb3IsIHVlID0gY29uc29sZS5ncm91cCwgbGUgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCBjZSA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogZmUsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IGUsXG4gICAgICAgICAgICBsb2c6IGUsXG4gICAgICAgICAgICB3YXJuOiBlLFxuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBncm91cDogZSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBlLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBEKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRC0tLCBEID09PSAwKSB7XG4gICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogYWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogb2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogaWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogbGVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEQgPCAwICYmIEUoXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSiA9IGsuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgcTtcbiAgICBmdW5jdGlvbiBOKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHEgPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHUuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBxID0gbiAmJiBuWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIHEgKyBlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRyA9ICExLCBWO1xuICAgIHtcbiAgICAgIHZhciBKZSA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBWID0gbmV3IEplKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlKGUsIHIpIHtcbiAgICAgIGlmICghZSB8fCBHKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBWLmdldChlKTtcbiAgICAgICAgaWYgKHQgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHZhciBuO1xuICAgICAgRyA9ICEwO1xuICAgICAgdmFyIHUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIGw7XG4gICAgICBsID0gSi5jdXJyZW50LCBKLmN1cnJlbnQgPSBudWxsLCB6ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2YXIgcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QocywgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICAgICAgICBuID0gUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGUsIFtdLCBzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcy5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICAgIG4gPSBTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jYWxsKHMucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICAgICAgbiA9IFM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICBpZiAoUyAmJiBuICYmIHR5cGVvZiBTLnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0gUy5zdGFjay5zcGxpdChgXG5gKSwgZyA9IG4uc3RhY2suc3BsaXQoYFxuYCksIGQgPSBvLmxlbmd0aCAtIDEsIHYgPSBnLmxlbmd0aCAtIDE7IGQgPj0gMSAmJiB2ID49IDAgJiYgb1tkXSAhPT0gZ1t2XTsgKVxuICAgICAgICAgICAgdi0tO1xuICAgICAgICAgIGZvciAoOyBkID49IDEgJiYgdiA+PSAwOyBkLS0sIHYtLSlcbiAgICAgICAgICAgIGlmIChvW2RdICE9PSBnW3ZdKSB7XG4gICAgICAgICAgICAgIGlmIChkICE9PSAxIHx8IHYgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChkLS0sIHYtLSwgdiA8IDAgfHwgb1tkXSAhPT0gZ1t2XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgVCA9IGBcbmAgKyBvW2RdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lICYmIFQuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoVCA9IFQucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGUuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIFYuc2V0KGUsIFQpLCBUO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkID49IDEgJiYgdiA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIEcgPSAhMSwgSi5jdXJyZW50ID0gbCwgQmUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1O1xuICAgICAgfVxuICAgICAgdmFyIEYgPSBlID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgOiBcIlwiLCBDZSA9IEYgPyBOKEYpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgVi5zZXQoZSwgQ2UpLCBDZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcWUoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIGRlKGUsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR2UoZSkge1xuICAgICAgdmFyIHIgPSBlLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShyICYmIHIuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE0oZSwgciwgdCkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZGUoZSwgR2UoZSkpO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBOKGUpO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgdzpcbiAgICAgICAgICByZXR1cm4gTihcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIE4oXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBmOlxuICAgICAgICAgICAgcmV0dXJuIHFlKGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICByZXR1cm4gTShlLnR5cGUsIHIsIHQpO1xuICAgICAgICAgIGNhc2UgTzoge1xuICAgICAgICAgICAgdmFyIG4gPSBlLCB1ID0gbi5fcGF5bG9hZCwgbCA9IG4uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gTShsKHUpLCByLCB0KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBVID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgdmUgPSB7fSwgcGUgPSBrLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24geihlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0gTShlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBwZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcGUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBIZShlLCByLCB0LCBuLCB1KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBsID0gRnVuY3Rpb24uY2FsbC5iaW5kKFUpO1xuICAgICAgICBmb3IgKHZhciBzIGluIGUpXG4gICAgICAgICAgaWYgKGwoZSwgcykpIHtcbiAgICAgICAgICAgIHZhciBvID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlW3NdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBnID0gRXJyb3IoKG4gfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIHQgKyBcIiB0eXBlIGBcIiArIHMgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGVbc10gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IGcubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG8gPSBlW3NdKHIsIHMsIG4sIHQsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChkKSB7XG4gICAgICAgICAgICAgIG8gPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbyAmJiAhKG8gaW5zdGFuY2VvZiBFcnJvcikgJiYgKHoodSksIEUoXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIG4gfHwgXCJSZWFjdCBjbGFzc1wiLCB0LCBzLCB0eXBlb2YgbyksIHoobnVsbCkpLCBvIGluc3RhbmNlb2YgRXJyb3IgJiYgIShvLm1lc3NhZ2UgaW4gdmUpICYmICh2ZVtvLm1lc3NhZ2VdID0gITAsIHoodSksIEUoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgdCwgby5tZXNzYWdlKSwgeihudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgS2UgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIEgoZSkge1xuICAgICAgcmV0dXJuIEtlKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBaZShlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnLCB0ID0gciAmJiBlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBYZShlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYmUoZSksICExO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYmUoZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFZShlKSB7XG4gICAgICBpZiAoWGUoZSkpXG4gICAgICAgIHJldHVybiBFKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIFplKGUpKSwgYmUoZSk7XG4gICAgfVxuICAgIHZhciBJID0gay5SZWFjdEN1cnJlbnRPd25lciwgUWUgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBnZSwgaGUsIEs7XG4gICAgSyA9IHt9O1xuICAgIGZ1bmN0aW9uIGVyKGUpIHtcbiAgICAgIGlmIChVLmNhbGwoZSwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnIoZSkge1xuICAgICAgaWYgKFUuY2FsbChlLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cihlLCByKSB7XG4gICAgICBpZiAodHlwZW9mIGUucmVmID09IFwic3RyaW5nXCIgJiYgSS5jdXJyZW50ICYmIHIgJiYgSS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gcikge1xuICAgICAgICB2YXIgdCA9IEMoSS5jdXJyZW50LnR5cGUpO1xuICAgICAgICBLW3RdIHx8IChFKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFRoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uIFdlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgQyhJLmN1cnJlbnQudHlwZSksIGUucmVmKSwgS1t0XSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnIoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGdlIHx8IChnZSA9ICEwLCBFKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBoZSB8fCAoaGUgPSAhMCwgRShcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3IgPSBmdW5jdGlvbihlLCByLCB0LCBuLCB1LCBsLCBzKSB7XG4gICAgICB2YXIgbyA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IGgsXG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIGtleTogcixcbiAgICAgICAgcmVmOiB0LFxuICAgICAgICBwcm9wczogcyxcbiAgICAgICAgX293bmVyOiBsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG8uX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBuXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiB1XG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShvLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShvKSksIG87XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpcihlLCByLCB0LCBuLCB1KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBsLCBzID0ge30sIG8gPSBudWxsLCBnID0gbnVsbDtcbiAgICAgICAgdCAhPT0gdm9pZCAwICYmIChFZSh0KSwgbyA9IFwiXCIgKyB0KSwgcnIocikgJiYgKEVlKHIua2V5KSwgbyA9IFwiXCIgKyByLmtleSksIGVyKHIpICYmIChnID0gci5yZWYsIHRyKHIsIHUpKTtcbiAgICAgICAgZm9yIChsIGluIHIpXG4gICAgICAgICAgVS5jYWxsKHIsIGwpICYmICFRZS5oYXNPd25Qcm9wZXJ0eShsKSAmJiAoc1tsXSA9IHJbbF0pO1xuICAgICAgICBpZiAoZSAmJiBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBkID0gZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChsIGluIGQpXG4gICAgICAgICAgICBzW2xdID09PSB2b2lkIDAgJiYgKHNbbF0gPSBkW2xdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobyB8fCBnKSB7XG4gICAgICAgICAgdmFyIHYgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBcIlVua25vd25cIiA6IGU7XG4gICAgICAgICAgbyAmJiBucihzLCB2KSwgZyAmJiBhcihzLCB2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3IoZSwgbywgZywgdSwgbiwgSS5jdXJyZW50LCBzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFogPSBrLlJlYWN0Q3VycmVudE93bmVyLCBtZSA9IGsuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBBKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSBNKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIG1lLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBYO1xuICAgIFggPSAhMTtcbiAgICBmdW5jdGlvbiBRKGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgZS4kJHR5cGVvZiA9PT0gaDtcbiAgICB9XG4gICAgZnVuY3Rpb24geWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChaLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZSA9IEMoWi5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGUgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciByID0gZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgdCA9IGUubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIHIgKyBcIjpcIiArIHQgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFJlID0ge307XG4gICAgZnVuY3Rpb24gdXIoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IHllKCk7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHZhciB0ID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZTtcbiAgICAgICAgICB0ICYmIChyID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgdCArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFlLl9zdG9yZSB8fCBlLl9zdG9yZS52YWxpZGF0ZWQgfHwgZS5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgdCA9IHVyKHIpO1xuICAgICAgICBpZiAoUmVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBSZVt0XSA9ICEwO1xuICAgICAgICB2YXIgbiA9IFwiXCI7XG4gICAgICAgIGUgJiYgZS5fb3duZXIgJiYgZS5fb3duZXIgIT09IFouY3VycmVudCAmJiAobiA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgQyhlLl9vd25lci50eXBlKSArIFwiLlwiKSwgQShlKSwgRSgnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgdCwgbiksIEEobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoSChlKSlcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHZhciBuID0gZVt0XTtcbiAgICAgICAgICAgIFEobikgJiYgX2Uobiwgcik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChRKGUpKVxuICAgICAgICAgIGUuX3N0b3JlICYmIChlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGUpIHtcbiAgICAgICAgICB2YXIgdSA9IEllKGUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgJiYgdSAhPT0gZS5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IHUuY2FsbChlKSwgczsgIShzID0gbC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgUShzLnZhbHVlKSAmJiBfZShzLnZhbHVlLCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBscihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gZS50eXBlO1xuICAgICAgICBpZiAociA9PSBudWxsIHx8IHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaWYgKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgKHIuJCR0eXBlb2YgPT09IGYgfHwgci4kJHR5cGVvZiA9PT0gUikpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciBuID0gQyhyKTtcbiAgICAgICAgICBIZSh0LCBlLnByb3BzLCBcInByb3BcIiwgbiwgZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoci5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhWCkge1xuICAgICAgICAgIFggPSAhMDtcbiAgICAgICAgICB2YXIgdSA9IEMocik7XG4gICAgICAgICAgRShcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCB1IHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2Ygci5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFyLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBFKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IE9iamVjdC5rZXlzKGUucHJvcHMpLCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICB2YXIgbiA9IHJbdF07XG4gICAgICAgICAgaWYgKG4gIT09IFwiY2hpbGRyZW5cIiAmJiBuICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBBKGUpLCBFKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgbiksIEEobnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5yZWYgIT09IG51bGwgJiYgKEEoZSksIEUoXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgQShudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9lKGUsIHIsIHQsIG4sIHUsIGwpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHMgPSBNZShlKTtcbiAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgdmFyIG8gPSBcIlwiO1xuICAgICAgICAgIChlID09PSB2b2lkIDAgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gMCkgJiYgKG8gKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgZyA9IHNyKHUpO1xuICAgICAgICAgIGcgPyBvICs9IGcgOiBvICs9IHllKCk7XG4gICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgZSA9PT0gbnVsbCA/IGQgPSBcIm51bGxcIiA6IEgoZSkgPyBkID0gXCJhcnJheVwiIDogZSAhPT0gdm9pZCAwICYmIGUuJCR0eXBlb2YgPT09IGggPyAoZCA9IFwiPFwiICsgKEMoZS50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBvID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBkID0gdHlwZW9mIGUsIEUoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgZCwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBpcihlLCByLCB0LCB1LCBsKTtcbiAgICAgICAgaWYgKHYgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICB2YXIgVCA9IHIuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKFQgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICBpZiAoSChUKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEYgPSAwOyBGIDwgVC5sZW5ndGg7IEYrKylcbiAgICAgICAgICAgICAgICAgIFRlKFRbRl0sIGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShUKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgRShcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIFRlKFQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlID09PSB5ID8gY3IodikgOiBscih2KSwgdjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZnIoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIE9lKGUsIHIsIHQsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHIoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIE9lKGUsIHIsIHQsICExKTtcbiAgICB9XG4gICAgdmFyIHZyID0gZHIsIHByID0gZnI7XG4gICAgVy5GcmFnbWVudCA9IHksIFcuanN4ID0gdnIsIFcuanN4cyA9IHByO1xuICB9KCkpLCBXO1xufVxuKGZ1bmN0aW9uKGkpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaS5leHBvcnRzID0gaHIoKSA6IGkuZXhwb3J0cyA9IG1yKCk7XG59KShGZSk7XG5jb25zdCB4ZSA9IEZlLmV4cG9ydHMuanN4LCBUciA9ICh7XG4gIGNsYXNzTmFtZTogaSxcbiAgb25SZWFkeTogaFxufSkgPT4ge1xuICBjb25zdCBtID0gU2UobnVsbCksIHkgPSBTZShudWxsKTtcbiAgcmV0dXJuIEFlKCgpID0+IHtcbiAgICBjb25zdCBwID0gbmV3ICQuQ2FudmFzKG0uY3VycmVudCksIF8gPSAoKSA9PiB7XG4gICAgICB2YXIgYywgZjtcbiAgICAgIHAuc2V0SGVpZ2h0KCgoYyA9IHkuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGMuY2xpZW50SGVpZ2h0KSB8fCAwKSwgcC5zZXRXaWR0aCgoKGYgPSB5LmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBmLmNsaWVudFdpZHRoKSB8fCAwKSwgcC5yZW5kZXJBbGwoKTtcbiAgICB9LCBhID0gKCkgPT4ge1xuICAgICAgXygpO1xuICAgIH07XG4gICAgcmV0dXJuIF8oKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgYSwgITEpLCBoICYmIGgocCksICgpID0+IHtcbiAgICAgIHAuZGlzcG9zZSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBhKTtcbiAgICB9O1xuICB9LCBbXSksIC8qIEBfX1BVUkVfXyAqLyB4ZShcImRpdlwiLCB7XG4gICAgcmVmOiB5LFxuICAgIGNsYXNzTmFtZTogaSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHhlKFwiY2FudmFzXCIsIHtcbiAgICAgIHJlZjogbVxuICAgIH0pXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIFRyIGFzIEZhYnJpY0pTQ2FudmFzLFxuICBfciBhcyB1c2VGYWJyaWNKU0VkaXRvclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fabricjs-react/dist/fabricjs-react.es.js\n");

/***/ })

};
;